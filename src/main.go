package main

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"os"

	_ "github.com/mattn/go-sqlite3"

	"github.com/rl4debug/m-dapp/src/dapp"
)

type FullItem struct {
	Item *dapp.ProjectItem
	Des  string
	Tags []string
	Site string
}

var ChFullItems = make(chan FullItem, 10)
var ChFetchItems = make(chan dapp.ProjectItem, 10)
var maxFetcher = 1
var chMax = make(chan bool, maxFetcher)
var chFails = make(chan string, 10)

func main() {
	return
	var items, _ = readItems()

	go fetchWorker()
	go updateDbWorker()
	go failWorker()

	go func() {
		for _, item := range items {
			ChFetchItems <- item
		}
	}()

	var wc = make(chan struct{})
	<-wc //wait
}

func tryCollectItems(expected int) {
	var mm = make(map[string]dapp.ProjectItem)
	for a := 'a'; a <= 'z'; a++ {
		var link = "https://api.stateofthedapps.com/v1/dapps?category=new&limit=2000&offset=0&refine=any&seed=1813215562&text=" + string(a)
		var m = getItems(link)
		for _, it := range m {
			if _, ok := mm[it.Id]; !ok {
				mm[it.Id] = it
			}

			if len(mm) == expected {
				fmt.Printf("FULL")

				//Save to file
				var objs = make([]dapp.ProjectItem, expected)
				var index = 0
				for _, obj := range mm {
					objs[index] = obj
					index++
				}

				var data, _ = json.Marshal(objs)
				ioutil.WriteFile("hi.json", data, 0666)
				return
			}
		}

		fmt.Println("size: ", len(mm))
	}
}

func getItems(link string) dapp.ProjectItems {
	req, err := http.NewRequest("GET", link, nil)
	if err != nil {
		panic(err)
	}
	req.Header.Set("Pragma", "no-cache")
	req.Header.Set("Origin", "https://www.stateofthedapps.com")
	// req.Header.Set("Accept-Encoding", "gzip, deflate, br")
	req.Header.Set("Accept-Language", "en-US,en;q=0.9,vi;q=0.8")
	req.Header.Set("User-Agent", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36")
	req.Header.Set("Accept", "application/json, text/plain, */*")
	req.Header.Set("Cache-Control", "no-cache")
	req.Header.Set("Authority", "api.stateofthedapps.com")
	req.Header.Set("Referer", "https://www.stateofthedapps.com/tab/new")

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()

	var ret dapp.ProjectItems
	var data, _ = ioutil.ReadAll(resp.Body)
	json.Unmarshal(data, &ret)
	return ret
}

func readItems() (dapp.ProjectItems, error) {
	data, err := ioutil.ReadFile("../notes/full.json")
	if err != nil {
		return nil, err
	}

	// fmt.Println(string(data))

	var pItems dapp.ProjectItems
	err = json.Unmarshal(data, &pItems)
	if err != nil {
		return nil, err
	}

	return pItems, err
}

func failWorker() {
	ioutil.WriteFile("fail", nil, 0600)
	f, err := os.OpenFile("fail", os.O_APPEND|os.O_WRONLY, 0600)
	if err != nil {
		panic(err)
	}

	for id := range chFails {
		f.Write([]byte(id + "\n"))
	}
}

func fetchWorker() {
	for item := range ChFetchItems {
		select {
		case chMax <- true: //If available
			var it = dapp.ProjectItem{
				Author:      item.Author,
				Badges:      item.Badges,
				Clicks:      item.Clicks,
				Id:          item.Id,
				Impressions: item.Impressions,
				IsNew:       item.IsNew,
				IsNsfw:      item.IsNsfw,
				Name:        item.Name,
				Score:       item.Score,
				Slug:        item.Slug,
				Status:      item.Status,
				SubAuthors:  item.SubAuthors,
				Teaser:      item.Teaser,
			}
			it.Badges = item.Badges

			go func(it dapp.ProjectItem) {
				err := fetch(&it)
				if err != nil {

					//Fail => Update fail
					chFails <- it.Id
				}

				//Done => free 1 slot
				<-chMax
			}(it)
		}
	}
}

func fetch(item *dapp.ProjectItem) error {

	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go
	var link = "https://api.stateofthedapps.com/v1/dapps/" + item.Id
	req, err := http.NewRequest("GET", link, nil)
	if err != nil {
		// handle err
	}
	req.Header.Set("Pragma", "no-cache")
	req.Header.Set("Origin", "https://www.stateofthedapps.com")
	// req.Header.Set("Accept-Encoding", "gzip, deflate, br")
	// req.Header.Set("Accept-Encoding", "gzip, deflate, br")
	req.Header.Set("Accept-Language", "en-US,en;q=0.9,vi;q=0.8")
	req.Header.Set("User-Agent", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36")
	req.Header.Set("Accept", "application/json, text/plain, */*")
	req.Header.Set("Cache-Control", "no-cache")
	req.Header.Set("Authority", "api.stateofthedapps.com")
	req.Header.Set("Referer", "https://www.stateofthedapps.com/")

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	var detailItem dapp.ProjectDetailItem
	data, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return err
	}

	err = json.Unmarshal(data, &detailItem)
	if err != nil {
		fmt.Println(string(data))
		fmt.Println("day roi: ", err)
		return err
	}

	var it = *item
	//compose full item
	var fullItem = FullItem{
		Item: &it,
		Des:  detailItem.Des,
		Site: detailItem.Site,
		Tags: detailItem.Tags,
	}

	ChFullItems <- fullItem

	return nil
}

func updateDbWorker() {
	db, err := initDB("../db")
	if err != nil {
		fmt.Println("UpdateDbWorker: ", err)
		return
	}

	for item := range ChFullItems {
		var it = item
		err := storeFullItem(&it, db)
		if err != nil {
			fmt.Println("UpdateDbWorker: ", item.Item.Id, " :", err)
			return
		}

		fmt.Println(item.Item.Id)
	}
}

func initDB(filepath string) (*sql.DB, error) {
	db, err := sql.Open("sqlite3", filepath)
	if err != nil {
		panic(err)
	}
	if db == nil {
		return nil, err
	}
	return db, nil
}

func storeFullItem(item *FullItem, db *sql.DB) error {
	sqlQuery := `
	INSERT INTO project_item(
		id,
		des,
		is_new,
		is_ns_fw,
		author,
		sub_authors,
		name,
		slug,
		teaser,
		status,
		impressions,
		clicks,
		score,
		Site
	) values(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? ,? , ?, ?)
	`

	stmt, err := db.Prepare(sqlQuery)
	if err != nil {
		return err
	}
	defer stmt.Close()

	_, err = stmt.Exec(
		item.Item.Id,
		item.Des,
		item.Item.IsNew,
		item.Item.IsNsfw,
		item.Item.Author,
		item.Item.SubAuthors,
		item.Item.Name,
		item.Item.Slug,
		item.Item.Teaser,
		item.Item.Status,
		item.Item.Impressions,
		item.Item.Clicks,
		item.Item.Score,
		item.Site,
	)
	if err != nil {
		fmt.Println("hihi")
		return err
	}

	err = storeBadges(item.Item.Id, item.Item.Badges, db)
	if err != nil {
		return err
	}

	err = storeTags(item.Item.Id, item.Tags, db)
	if err != nil {
		return err
	}

	return nil
}

func storeBadges(id string, badges []string, db *sql.DB) error {
	sqlQuery := `
	INSERT INTO project_badge (
		id,
		badge
	) values (?, ?)
	`

	stmt, err := db.Prepare(sqlQuery)
	if err != nil {
		return err
	}
	defer stmt.Close()

	for _, badge := range badges {
		_, err = stmt.Exec(
			id,
			badge,
		)
		if err != nil {
			return err
		}
	}

	return nil
}

func storeTags(id string, tags []string, db *sql.DB) error {
	sqlQuery := `
	INSERT INTO project_tag (
		id,
		tag
	) values (?, ?)
	`

	stmt, err := db.Prepare(sqlQuery)
	if err != nil {
		return err
	}
	defer stmt.Close()

	for _, tag := range tags {
		_, err = stmt.Exec(
			id,
			tag,
		)
		if err != nil {
			return err
		}
	}

	return nil
}
